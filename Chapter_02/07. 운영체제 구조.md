

- 운영체제는 크고 복잡한 시스템이지만, 이를 유연하고 효율적으로 작동하게 하려면 신중한 설계가 필요하다. 
- 운영체제는 하나의 큰 시스템으로 동작하기보다는 여러 태스크를 작은 구성 요소로 나누어 처리하는 방식으로 설계된다. 
- 즉, 하나의 메인 함수에서 모든 코드를 처리하는 대신, 각 기능을 독립적인 모듈로 분리해 관리하는 것이 중요하다. 
- 또한, 각 모듈마다 적절한 예외 처리를 통해 오류 발생 시에도 안정적인 동작을 보장해야 한다.

## 모놀리식 구조

운영체제를 구성하는데 가장 간단한 구조는 구조가 없는 것이다.
시스템의 모든 기능이 하나의 이진파일로 배포되는 구조이다.

![[Pasted image 20241001152710.png]]

장점
>구조가 간결하고 속도에서 효율성을 갖는다.

단점
>구성 중 하나를 고치고자 할 때 전체에 영향을 줄 수 있다.
>이에 따라 유연성이 부족해진다.

---
## 계층적 접근

모놀리식 구조가 시스템의 한 부분을 변경하면 다른 부분에 광범위하게 영향을 주어 **밀접하게 결합된** 시스템으로 불린다면 반대로 **느슨하게 결합된** 시스템을 설계할 수 있을 것이다.

느슨하게 결합된 시스템은 기능을 개별적인 작은 구성 요소로 나누어 설계되며, 모놀리식 구조와 달리 한 부분의 변경이 그 부분에만 영향을 미치는 장점을 가진다.

이러한 설계 방식 중 하나가 **계층적 접근**이다. 
계층적 접근의 핵심은 상위 계층이 자신보다 낮은 계층의 연산을 호출하여 기능을 수행하는 것이다. 
시스템이 실행될 때는 최하위 계층부터 순차적으로 디버깅이 이루어지며, 예를 들어 3번째 계층에서 오류가 발생하면 3번째 계층에 문제가 있는 것으로 간주할 수 있다. 
이는 0~2번째 계층이 정상적으로 디버깅되었기 때문이다.

이것을 무조건 0~2번 계층은 문제가 없다! 라고 할 수 는 없다.
오류가 발생한 지점을 좁혀갈 수 있다는 점이 중요한 것이다.

하지만 단점도 존재한다. 모놀리식 구조와는 정반대로 **속도** 문제가 발생할 수 있다. 상위 계층에서 하나의 연산을 수행할 때 하위 계층의 기능을 호출하여 필요한 데이터를 가져오는 과정이 추가되기 때문이다.

---
## 마이크로 커널

초기 UNIX는 모놀리식 구조는 갖는다. UNIX가 확장함에 따라, 커널이 커지고 관리가 어려워졌다.
1980년대 중반에, Carnegie-Mellon 대학교의 연구자들이 마이크로커널 접근 방식을 사용하여 커널을 모듈화한 Mach라 불리는 운영체제를 개발 하였다.

마이크로커널은 기존 운영체제의 커널에서 기본적으로 필요한 부분만 남기고 모두 사용자 영역으로 밀어내고 커널을 가볍게 만들었다.
이전과 달리 클라이언트 프로그램이 서비스와 직접 상호작용 하는 것이 아닌 마이크로커널을 통한 메세지 교환으로 상호작용이 이루어진다.

만약 한 서비스가 잘못되어도, 운영체제의 다른 부분에는 아무런 영향이 미치지 않는다.

마이크로커널에서 중요한 부분은 운영체제 기능을 최소화 하여 , 프로세스 간 통신(IPC)을 통해 필요한 서비스를 요청하는 방식이라는 것이다.

단점
>마이크로커널에서 클라이언트와 서비스 간의 모든 상호작용은 메시지 기반의 IPC로 이루어지기 때문에, 모놀리식 커널에 비해 **추가적인 오버헤드**가 발생한다. 
>특히, 많은 양의 데이터나 빈번한 요청이 있을 때 IPC의 오버헤드가 성능에 부정적인 영향을 미칠 수 있다.

---
## 모듈

운영체제를 설계하는 데 이용되는 최근 기술 중 최선책은 아마도 LKM(적재 가능 커널 모듈) 기법의 사용일 것이다. 
이 접근법에서는 커널은 핵심적인 집합을 가지고 있고 부팅 또는 실행 중에 부가적인 서비스들을 모듈을 통해 링크할 수 있다.

이 설계의 중요한 부분은 커널은 핵심 서비스를 제공하고 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것이다. 서비스를 동적으로 링크하는 것은 수정 사항이 생길 때마다 커널을 다시 컴파일하는 새로운 기능을 커널에 직접 추가하는 방식보다 바람직하다.

커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조와 닮았지만 특정 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다 유연하고
중심 모듈은 핵심 기능만 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점에서 마이크로커널과 유사하지만 통신을 위한 메세지 사용이 없다는 점에서 더 효율적이다.

---
## 하이브리드 시스템

#### MacOS & iOS

MacOS는 데스크탑과 랩탑을 위한 것이며 iOS는 iPhone 및 iPad를 위한 모바일 운영체제이다.

- 사용자 경험 층
>MacOS : 마우스 또는 트랙패드 용으로 설계된 Aqua 사용자 인터페이스
>iOS : 터치 장치용으로 설계된 Springboard 사용자 인터페이스
	
- 응용 프로그램 프레임워크 층
> Cocoa 및 Cocoa Touch 프레임워크가 포함되며 Objective-C 및 Swift 프로그래밍 언어에 대한 API를 제공한다. [간단한 Cocoa 설명](https://babbab2.tistory.com/51)

- 핵심 프레임워크
>이 층에서는 Quicktime 및 OpenGL을 포함한 그래픽 및 미디어를 지원하는 프레임워크를 정의한다.

- 커널 환경
>Darwin이라고도 불리는 이 환경에서는 Mach 마이크로커널과 BSD UNIX 커널이 포함된다.

- MacOS & iOS 의 차이점
>iOS는 모바일 장치용이라는 차이점과 MacOS에 비해 개발자에게 폐쇄적이라는 점이다.
>예를 들어, iOS는 iOS에서 POSIX 및 BSD API에 대한 액세스를 제한하는 반면 MacOS에서는 공개적으로 사용 가능하다.


##### Darwin

Darwin은 주로 Mach 마이크로커널과 BSD UNIX 커널로 구성된 계층화된 시스템이다.

운영체제 대부분은 UNIX & Linux 시스템에서 표준 C-lib를 통하는 것처럼 커널에 대해 하나의 시스템 콜 인터페이스를 제공하는 반면 Darwin은 Mach 트랩과 BSD 시스템 콜(POSIX 기능 제공) 두 개의 시스템 콜 인터페이스를 제공한다.
이러한 시스템 콜에 대한 인터페이스는 C-lib뿐만 아니라 네트워킹, 보안 및 프로그래밍 언어 지원을 제공하는 라이브러리를 포함하는 풍부한 라이브러리 집합이다.


- 인터럽트(하드웨어 인터럽트)

>CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능
- 트랩(소프트웨어 인터럽트)

>오류나 예외 조건 때문에 발생
- 시스템 콜

>응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스(API)

##### Mach

시스템 콜 인터페이스 아래에서 Mach는 메모리 관리, CPU 스케줄링 및 메세지 전달 및 원격 프로시저 호출과 같은 프로세스 간 통신(IPC) 기능을 포함한 기본 운영체제 서비스를 제공한다.
Mach에서 제공하는 대부분의 기능은 커널 추상화를 통해 사용 가능하다.
이 추상화에는 타스크(Mach 프로세스), 스레드 메모리 객체 및 포트(IPC에 사용)가 포함된다.

예를 들어, 응용 프로그램은 BSD POSIX fork() 시스템 콜을 사용하여 새 프로세스를 생성할 수 있다.
Mach는 커널 내에서 프로세스를 나타내기 위하여 태스크 커널 추상화를 사용한다.
이는 태스크는 프로세스가 실행되는 데 필요한 **자원**과 **메모리**를 관리한다는 의미이다.

이전 마이크로커널에서 메세지 전달로 인한 성능 저하 내용이 있었다.
Darwin 또한 하나의 마이크로커널 구조이기 때문에 분명 이 문제가 있었을 것이다.
Darwin은 이 문제를 해결하기 위해 Mach, BSD, I/O 및 모든 커널 확장을 단일 주소 공간으로 결합한다. 따라서 다양한 하위 시스템이 사용자 공간에서 실행된다는 관점에서 본다면 Mach는 순수한 마이크로커널이 아닌 것이다.
Mach내에서 메세지 전달은 여전히 발생하지만 서비스가 동일한 주소 공간에서 액세스 가능하므로 복사와 같은 행위를 할 필요가 없다.


#### Android

Android 운영체제는 Google이 주도하여 설계되었으며 스마트폰 및 태블릿을 위해 개발 되었다.
iOS와 달리 오픈 소스라는 차이점이 있다.

Android 장치의 SW 설계자는 Java 언어로 응용 프로그램을 개발하지만 일반적으로 표준 Java API를 사용하지 않는다. Google은 Java 개발을 위해 별도의 Android API를 설계하였다. Java 응용 프로그램은 ART(Android RunTime)에서 실행할 수 있는 형식으로 컴파일 된다.

ART는 Andriod용으로 설계되어 메모리와 CPU 처리 능력이 제한적인 모바일 장치에 최적화된 VM이다.
많은 Java VM이 응용 프로그램 효율성을 향상 시키기 위해 JTT컴파일을 수행하는 반면 ART는 AOT(ahead-of-time) 컴파일을 수행한다.

Android는 거의 무제한의 하드웨어 장치에서 실행될 수 있으므로 Google은 하드웨어 추상화 계층 또는 HAL을 통해 물리적 하드웨어를 추상화하기로 선택했다.
이 기능을 통해 개발자는 다른 하드웨어 플랫폼에서 이식 가능한 프로그램을 작성할 수 있다.
HAL : 하드웨어 추상화 레이어(Hardware Abstraction Layer)'의 약자

Linux 시스템에서 사용하는 표준 C-lib는 GNU C-lib(glibc)이다.
대신 Google은 Android를 위한 Bionic 표준 C-lib를 개발하였다.
glibc보다 메모리 사용량이 적고 모바일 장치를 특징짓는 느린 CPU를 위해 설계되었다.


[[06. 응용 프로그램이 운영체제마다 다른 이유]]  | [[08. 운영체제 빌딩과 부팅]]
