

시스템 콜은 프로그램이 운영체제의 커널에 직접 요청을 보내어 하드웨어 자원이나 시스템 서비스를 사용할 수 있도록 하는 인터페이스이다.

예를 들어,
in.txt out.txt 명령으로 입력 파일을 출력 파일에 복사하거나.
사용자에게 이름을 요청하는 방식이 있다.
대화형 시스템에서 이 방법은 일련의 시스템 콜을 필요로 한다.
사용자에게 두 개의 파일 이름이 얻어지면, 프로그램은 반드시 입력 파일을 오픈하고 출력 파일을 생성한 후 오픈한다. 각각의 이러한 연산은 또 다른 시스템 콜을 필요로 하며, 각 시스템 콜에서 오류가 발생하면 처리되어야 한다.


시스템 콜의 예시
![[Pasted image 20240929153748.png]]
1. 입력파일 이름 획득
	1. 화면에 프롬프트 출력
	2. 입력 받아들임
2. 출력 파일 이름 획득
	1. 화면에 프롬프트 출력
	2. 입력 받아들임
3. 입력 파일 열기
	1. 파일이 존재하지 않을 경우, 비정상적으로 종료
4. 출력 파일 생성
	1. 파일이 존재할 경우, 비정상적으로 종료
5. 루프
	1. 입력 파일로부터 읽어 들임
	2. 출력 파일에 쓰기
6. 읽기가 실패할 때까지
7.  출력 파일 닫기
8. 화면에 완료 메세지 출력
9. 정상적으로 종료

---
## API (Application Programming Interface)

API는 응용 프로그래밍 인터페이스 이며, 대부분의 APP 개발자들이 이에 맞춰 프로그램을 설계한다.

API를 사용하는 과정은 다음과 같다.
1. 사용자가 특정 API를 요청 -> 시스템 콜 호출
2. 시스템 콜을 사용하여 사용자 모드에서 커널 모드로 전환
3. 해당 API의 시스템 콜을 처리하는 커널의 함수가 실행
이 과정을 통해 프로세스는 운영 체제의 기능을 사용할 수 있게 된다.

---
## RTE(실행시간 환경)

RTE는 응용 프로그램을 실행하는 데 필요한 전체 SW를 가리킨다고 하며
프로그램이 실행되는 동안 운영체제가 제공하는 메모리, 파일 시스템, 입출력 장치 등 시스템 자원을 관리하고 지원하는 환경을 의미한다.
메모리 할당, 파일 읽기/쓰기, 네트워크 통신 등의 작업이 실행시간 환경에서 관리된다.

---
## 매개변수 전달

1. **레지스터를 통한 전달**: 
	매개변수를 CPU 레지스터에 저장하여 시스템 콜을 호출하는 방식이다. 매개변수의 수가 적을 때 빠르고 효율적이며, 운영체제가 이 방식으로 매개변수를 처리할 수 있는 한계를 가진다. 
	-> x86 시스템에서 사용

2. **메모리 주소를 통한 전달**
	레지스터에 담을 수 있는 매개변수의 수가 제한적이므로, 더 많은 매개변수가 필요할 때는 메모리 내의 블록이나 테이블에 매개변수를 저장하고, 그 블록의 주소를 레지스터에 전달하는 방식이다.

Linux에서는 이 두 가지 방식을 조합하여, 매개변수가 **5개 이하**일 때는 **레지스터**에 직접 매개변수를 저장하고, **5개 이상**일 경우에는 매개변수를 **메모리 블록에 저장**한 후 그 블록의 주소를 레지스터에 전달하는 최적화된 방법을 사용한다.

3. **스택을 통한 전달**:
	매개변수는 프로그램에 의해 스택에 Push할 수 있고, 운영체제에 의해 pop off될 수 있다.

---
## 결론

Python의 Print 문은 어떤 시스템 콜을 가질 까?라는 의문이 생겼다.
1. 표준 출력 스트림에 데이터를 쓰기 위해 `Write` 시스템 콜을 호출
2. 출력 스트림을 열기 위해 `Open` 시스템 콜을 호출
3. 출력 스트림을 닫기 위해 `Close` 시스템 콜을 호출
4. 출력 버퍼를 비우기 위해 `Flush` 시스템 콜을 호출
등의  동작이 내부적으로 처리된다고 한다.

그런데 우리는 이러한 과정을 알아야할까?
책에서는 굳이 호출자(사용자)가 시스템 콜이 어떻게 구현되고 실행 중 무슨 작업을 하는지 아무것도 알 필요가 없다고 한다.
호출자(사용자)는 단지 API를 준수하고 시스템 콜의 결과로서 운영체제가 무엇을 할 것 인지만 이해하면 된다고 기술하였다.


---
## 시스템 콜의 유형

윈도우와 UNIX 시스템 콜의 예시
![[Pasted image 20240929161127.png]]

#### 프로세스 제어
- 끝내기(end, 정상종료), 중지(abort, 비정상종료)
- 적재(load), 수행(execute)
- 프로세스 생성, 종료
- 프로세스 속성(attributes) 획득, 설정
- 이벤트 대기, 이벤트 알림
- 메모리 할당 및 해제
- 데이터 일관성을 보장하기 위한 잠금(lock)

#### 단일 태스킹 & 다중 태스킹
- 단일 태스킹 -> Arduino
	![[Pasted image 20240930142642.png]]
	- USB 연결을 통해 컴파일된 프로그램(스케치)를 PC에서 Arduino의 플래시 메모리에 업로드
	- 표준 Arduino 플랫폼은 운영체제를 제공하지 않고 부트 로더가 스케치를 Arduino 메모리의 특정 영역으로 적재
	- Arduino는 한 순간에 하나의 스케치만 메모리에 존재 가능하기에 단일 태스킹으로 간주함

- 다중 태스킹 -> FreeBSD
	![[Pasted image 20240930143232.png]]
	사용자가 시스템에 로그인할 때 사용자가 선택한 Shell이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램을 수행한다.
	- 새로운 프로세서를 시작하는 fork
	- 선택된 프로그램이 메모리에 적재되는 exec
	- 종료하는 exit
	가장 비슷한 형태가 Docker이다.
	물론 Docker는 운영체제가 아니기 때문에 다른 부분이 있지만
	Shell환경에서 운영체제를 관리할 수 있다는 점과
	이 때 Shell에서 여러 프로세스를 다중으로 실행 가능하다는 것이 중요하다.


#### 파일 조작
- 파일 생성(create file), 삭제(delete file)
- 열기(open), 닫기(close)
- 읽기, 쓰기, 위치 변경(reposition)
- 파일 속성 획득 및 설정

#### 장치 관리
- 장치를 요구(request devices), 장치를 방출(release devices)
- 읽기, 쓰기, 위치 변경(reposition)
- 장치 속성 획득, 장치 속성 설정
- 장치의 논리적 부착(attach)또는 분리(detach)

#### 정보 유지
- 시간과 날짜의 설정과 획득
- 시스템 데이터의 설정과 획득
- 프로세스, 파일, 장치 속성의 획득 및 설정

#### 통신
- 통신 연결의 생성, 제거
- 메세지 송신 및 수신
- 상태 정보 전달
- 원격 장치의 부착 및 분리

#### 보안
- 파일 권한 획득 및 설정

[[02. 사용자와 운영체제 인터페이스]]  | [[04. 시스템 서비스]]
